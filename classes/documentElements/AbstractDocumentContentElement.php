<?php

/*
 * Copyright (C) 2014 Nikolai Neff <admin@flatplane.de>.
 *
 * This file is part of Flatplane.
 *
 * Flatplane is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Flatplane is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Flatplane.  If not, see <http://www.gnu.org/licenses/>.
 */

namespace de\flatplane\documentElements;

use de\flatplane\interfaces\DocumentElementInterface;
use de\flatplane\utilities\PDF;
use RuntimeException;
use TCPDF;

//todo: formattierungsobjekte: newline, newpage, (h/v-space), clearpage?

//todo: complete documentation!
//todo: methoden sortieren


/**
 * Abstract class for all page elements like sections, text, images, formulas, ...
 * Provides basic common functionality.
 * @author Nikolai Neff <admin@flatplane.de>
 */
abstract class AbstractDocumentContentElement implements DocumentElementInterface
{
    //import functionality horizontally from traits to reduce code length
    use traits\ContentFunctions;
    use traits\NumberingFunctions;
    use traits\StyleFunctions;

    /**
     * @var DocumentElementInterface
     *  Contains a reference to the parent DocumentElement instance
     */
    protected $parent = null;

    protected $startYpos;

    /**
     * @var int
     *  type of the element
     */
    protected $type = 'PageElement';

    /**
     * @var bool
     *  defines if the element will recieve its own number
     */
    protected $enumerate = true;

    /**
     * @var string
     *  alternative (shorter) title to be used in lists for this element
     */
    protected $altTitle = '';

    /**
     * @var string
     *  title of the element
     */
    protected $title = '';

    /**
     * @var bool
     *  defines if the element will be displayed in autogenerated lists
     */
    protected $showInList = true;

    /**
     * @var mixed
     *  use a bool to completely allow/disallow subcontent for the element or
     *  define allowed types as array values: e.g. ['section', 'formula']
     *  todo: fix/use me?
     */
    protected $allowSubContent = true;

    /**
     * @var bool
     *  indicates if the element can be split across multiple pages
     */
    protected $isSplitable = false;

    /**
     * @var string
     *  name to identify the element in references
     *  //todo: unique?
     */
    protected $label = '';

    /**
     * @var string
     *  Number of the page this element gets printed on. If the element spans
     *  multiple pages, then this number references the first occurrence.
     */
    protected $page;

    /**
     * @var int
     *  todo: doc
     */
    protected $linearPage;

    /**
     * @var string
     *  identifier used to separate different pagegroups
     */
    protected $pageGroup = 'default';

    /**
     * @var array
     *  defines the elements margins in user-units. Standard keys are:
     *  'top', 'bottom', 'left', 'right'. Subclasses might define their own keys.
     *  If any of those are undefined, the value of the key 'default' is used.
     */
    protected $margins = ['default' => 0];

//    /**
//     * @var array
//     *  defines the elements paddings in user-units. Standard keys are:
//     *  'top', 'bottom', 'left', 'right'. Subclasses might define their own keys.
//     *  If any of those are undefined, the value of the key 'default' is used.
//     */
//    protected $paddings = ['default' => 0];

    protected $hyphenate = true;

    /**
     * @var int
     *  internal link identifier retured by TCPDF::AddLink()
     * @see TCPDF::AddLink()
     * @see TCPDF::SetLink()
     */
    protected $link;

    /**
     * This method is called on creating a new element.
     * @param array $config
     *  Array containing key=>value pairs wich overwrite the default properties.
     *  e.g.: $config = ['enumerate' => false] will disable numbering for the
     *  created instance
     */
    public function __construct(array $config)
    {
        $this->setConfig($config);
    }

    /**
     * @param array $config
     *  Array containing key=>value pairs wich overwrite the default properties.
     *  e.g.: $config = ['enumerate' => false] will disable numbering for the
     *  created instance
     */
    public function setConfig(array $config)
    {
        $this->testNoParent();
        foreach ($config as $key => $setting) {
            $name = 'set'.ucfirst($key);
            if (method_exists($this, $name)) {
                $this->$name($setting);
            } else {
                trigger_error(
                    "$key is not a valid Configuration option, ignoring",
                    E_USER_NOTICE
                );
            }
        }
    }

    /**
     * get a string representation of the current object
     * @return string
     */
    public function __toString()
    {
        return (string) $this->getTitle();
    }

    /**
     * Sets the parent to an instance implementing DocumentElementInterface
     * @param DocumentElementInterface $parent
     */
    public function setParent(DocumentElementInterface $parent)
    {
        $this->parent = $parent;
    }

    /**
     * Get the Parent of the current element
     * @return DocumentElementInterface
     */
    public function getParent()
    {
        return $this->parent;
    }

    /**
     * @return PDF
     */
    public function getPDF()
    {
        return $this->toRoot()->getPDF();
    }

    /**
     * Get the title of the current element
     * @return type
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * Get the elements type
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * Get the number of the page this element gets printed on. If the element
     * spans multiple pages, this number references the first occurrence.
     * @return int
     */
    public function getPage()
    {
        if (empty($this->page)) {
            $this->page = str_repeat(
                $this->toRoot()->getUnresolvedReferenceMarker(),
                $this->toRoot()->getAssumedPageNumberWidth()
            );
        }
        return $this->page;
    }

    /**
     * Set the pagenumber (start) of the current element
     * @param int $page
     */
    public function setPage($page)
    {
        //todo: use number here
        $this->page = $page;
    }

    /**
     * @throws RuntimeException
     */
    protected function testNoParent()
    {
        if ($this->getParent() !== null) {
            throw new RuntimeException(
                "The configuration can't be changed after setting the parent"
            );
        }
    }

    /**
     * @param bool $enumerate
     */
    public function setEnumerate($enumerate)
    {
        if ($this->getParent() !== null) {
            trigger_error(
                'setEnumerate() should not be called after adding the element '
                .'as content. Doing so might lead to erratic behavior regarding'
                .'element numbering. Please use the $settings array in the '
                .'constructor instead',
                E_USER_NOTICE
            ) ;
        }
        $this->enumerate = (bool) $enumerate;
    }

    /**
     * @param bool $showInList
     */
    public function setShowInList($showInList)
    {
        $this->showInList = (bool) $showInList;
    }

    /**
     * Set the elements title
     * @param string $title
     */
    public function setTitle($title)
    {
        $this->title = $title;
    }

    /**
     * Set the elements Margins
     * @param array $margins
     *  keys: 'top', 'bottom', 'left', 'right'
     *  values: (numeric) margin amount (user units)
     */
    public function setMargins(array $margins)
    {
        $this->margins = array_merge($this->margins, $margins);
    }

    /**
     * @return bool
     *  Indicates whether the element will recieve a number
     */
    public function getEnumerate()
    {
        return $this->enumerate;
    }

    /**
     * @return bool
     *  Indicates whether the element will be shown in lists for the elements type
     */
    public function getShowInList()
    {
        return $this->showInList;
    }

    /**
     * @return mixed
     *  Eiter returns a bool to enable or disable all subcontent or an array
     *  containing the names of allowed types
     */
    public function getAllowSubContent()
    {
        return $this->allowSubContent;
    }

    /**
     * determines whether an element can be split accross multiple pages
     * (Currently not implemented)
     * @return bool
     */
    public function getIsSplitable()
    {
        return $this->isSplitable;
    }

    /**
     * Get the label of the current Element. (used as reference Identifier)
     * @return string
     */
    public function getLabel()
    {
        return $this->label;
    }

    /**
     * set a label as identifier for references
     * @param string $label
     */
    public function setLabel($label)
    {
        $this->label = $label;
        if (!in_array($this, $this->toRoot()->getLabels())) {
            $this->toRoot()->addLabel($this);
        }
    }

    /**
     * Set the color used to fill cells.
     * @param array $fillColor
     *  Either one, tree or four elements indicating the color values for
     *  grayscale, RGB or CMYK colors
     * @see TCPDF::SetFillColor()
     */
    public function setFillColor(array $fillColor)
    {
        $this->fillColor = $fillColor;
    }

    /**
     * Get the minimum clearance (=margins) around the element for the specified
     * direction (e.g. 'top'). If no key is provides or the key does not exist,
     * a default value is returned.
     * @param string $key
     * @return mixed
     *  String or numeric margin amount
     */
    public function getMargins($key = null)
    {
        if ($key !== null && isset($this->margins[$key])) {
            return $this->margins[$key];
        } else {
            return $this->margins['default'];
        }
    }

    /**
     * Get the minimum inside clearane (=paddings) of the element. (Currently not
     * used)
     *
     * @param string $key
     * @return mixed
     */
    public function getPaddings($key = null)
    {
        if ($key !== null && isset($this->paddings[$key])) {
            return $this->paddings[$key];
        } else {
            return $this->paddings['default'];
        }
    }

    /**
     * Set an alternate version of the title (used in lists and the header).
     * @param type $altTitle
     */
    public function setAltTitle($altTitle)
    {
        $this->altTitle = $altTitle;
    }

    /**
     * Get an alternate version of the title (used in lists and the header).
     * If no alternate title is defined, the standard title is used.
     * @return string
     */
    public function getAltTitle()
    {
        if (empty($this->altTitle)) {
            return $this->getTitle();
        } else {
            return $this->altTitle;
        }
    }

    /**
     * Get often needed page dimensions for the current page inside the PDF
     * @return array
     *  Keys: pageWidth, textWidth, pageHeight, textHeight
     */
    public function getPageMeasurements()
    {
        $pdf = $this->getPDF();

        $pageWidth = $pdf->getPageWidth();
        $textWidth = $pageWidth - $pdf->getMargins()['left']
                                - $pdf->getMargins()['right'];

        $pageHeight = $pdf->getPageHeight();
        //margin bottom includes footnotes margin
        $textHeight = $pageHeight - $pdf->getMargins()['top']
                                  - $pdf->getMargins()['bottom'];

        return ['pageWidth' => $pageWidth,
                'textWidth' => $textWidth,
                'pageHeight' => $pageHeight,
                'textHeight' => $textHeight];
    }

    /**
     * Get Hyphenation settings (on/off)
     * @return bool
     */
    public function getHyphenate()
    {
        return $this->hyphenate;
    }

    /**
     * Enable or disable the elements content-hyphenation
     * @param bool $hyphenate
     */
    public function setHyphenate($hyphenate)
    {
        $this->hyphenate = $hyphenate;
    }

    /**
     * Hyphenate the title and (if present) the altTitle of the element using the
     * documents hyphenation options if the hyphenate property is set to true.
     */
    public function hyphenateTitle()
    {
        if ($this->getHyphenate()) {
            if ($this->getAltTitle() !== $this->getTitle()) {
                $this->setAltTitle(
                    $this->toRoot()->hypenateText($this->getAltTitle())
                );
            }
            $this->setTitle($this->toRoot()->hypenateText($this->getTitle()));
        }
    }

    /**
     * Get the vertical dimensions and the number of pages needed to display the
     * current element.
     * @param float $startYposition
     * @return Array
     *  keys: 'height', 'numPages', 'endYposition'
     */
    public function getSize($startYposition = null)
    {
        //todo: return width?
        $pdf = $this->getPDF();
        $pdf->startMeasurement($startYposition);
        $this->generateOutput();
        return $pdf->endMeasurement();
    }

    /**
     * Get the linear (starting) page number of the current element
     * @return int
     */
    public function getLinearPage()
    {
        return $this->linearPage;
    }

    /**
     * Set the linear (starting) page number of the current element
     * @param int $linearPage
     */
    public function setLinearPage($linearPage)
    {
        $this->linearPage = $linearPage;
    }

    /**
     * Creates a reference to a source
     * @param string $source
     *  the label defines by the sources setLabel() method
     * @param string $extras
     *  additional text (e.g. Pages 2-7) to be displayed in the reference text
     * @return string
     *  Formatted number and $extras to indicate the referenced source
     */
    public function cite($source, $extras = '')
    {
        //todo: doc
        //todo: own style for Cite!
        $root = $this->toRoot();
        $sourceList = $root->getSources();
        if (array_key_exists($source, $sourceList)) {
            $citeStyle = $root->getCitationStyle();

            $prefix = $root->getNumberingPrefix('source');
            $separator = $root->getNumberingSeparator('source');
            $postfix = $root->getNumberingPostfix('source');

            $cite = $prefix;

            foreach ($sourceList[$source]->getNumbers() as $number) {
                $cite .= $number->getFormattedValue();
                $cite .= $separator;
            }

            $cite = rtrim($cite, $separator); //remove last number separator

            if (!empty($extras)) {
                $cite .= $citeStyle['separator'].' '.$extras;
            }

            $cite .= $postfix;

            $sourceList[$source]->setParent($this);
        } else {
            trigger_error(
                'Source "'.$source.'" for citation not found',
                E_USER_NOTICE
            );

            //todo: use unresolvedrefmarker setting & styles for prefix/postfix
            $cite = '[???]';
            if (!empty($extras)) {
                $cite .= $citeStyle['separator'].' '.$extras;
            }
        }
        return $cite;
    }

    /**
     * Get the link identifier for the current element
     * @return ressource
     * @see TCPDF:addLink
     */
    public function getLink()
    {
        return $this->link;
    }

    /**
     * Set the link identifier for the current element
     * @param ressource $link
     * @see TCPDF::AddLink
     */
    public function setLink($link)
    {
        $this->link = $link;
    }

    /**
     * Get the pagegroup of the current element
     * @return string
     */
    public function getPageGroup()
    {
        return $this->pageGroup;
    }

    /**
     * Set the pagegroup for the current element.
     * This group is maintained by all following elements unless they specify a
     * new pagegroup
     * @param string $pageGroup
     */
    public function setPageGroup($pageGroup)
    {
        $this->pageGroup = $pageGroup;
    }

    /**
     * get the elements Y-starting position whithin its page
     * @return float
     */
    public function getStartYpos()
    {
        return $this->startYpos;
    }

    /**
     * Set the elements Y-starting position whithin its page
     * @param float $startYpos
     */
    public function setStartYpos($startYpos)
    {
        $this->startYpos = $startYpos;
    }
}
